---
import Layout from '../layouts/Layout.astro';
import StackyIntro from '../components/stacky-intro.astro';
---

<Layout
  meta={{ path: '/about-us' }}
  header={{
    show: true,
    links: []
  }}
  footer={{ show: true }}
>
  <main>
    <StackyIntro />
  </main>
</Layout>

<style>
  main {
    margin-top: calc(var(--spacing) * 27);
    margin-bottom: calc(var(--spacing) * 32);
    padding-inline: calc(var(--spacing) * 6);

    @media (min-width: 40rem) {
      margin-top: calc(var(--spacing) * 20);
      padding-inline: calc(var(--spacing) * 10);
    }

    @media (min-width: 60rem) {
      /* Adjust the margin to the footer when the image moves to the side. */
      margin-bottom: calc(var(--spacing) * 46);
    }

    display: flex;
    flex-direction: column;
    align-items: center;
  }
</style>

<script>
  class Point {
    constructor(readonly x: number, readonly y: number) {
    }

    distanceTo(target: Point) {
      return Math.sqrt(
        Math.pow(this.x - target.x, 2) + Math.pow(this.y - target.y, 2)
      );
    }
  }

  class Vector {
    constructor(readonly x: number, readonly y: number) {
    }

    get magnitude(): number {
      return Math.sqrt(
        Math.pow(this.x, 2) + Math.pow(this.y, 2)
      );
    }

    get normalized(): Vector {
      const magnitude = this.magnitude;
      return new Vector(this.x / magnitude, this.y / magnitude);
    }

    multiply(magnitude: number): Vector {
      return new Vector(this.x * magnitude, this.y * magnitude);
    }
  }

  type Side = 'left' | 'right';

  class Eye {
    readonly center: Point;
    readonly radius: number;

    constructor(
      readonly side: Side,
      readonly socket: SVGRectElement,
      readonly iris: SVGEllipseElement
    ) {
      this.center = new Point(
        Number(socket.getAttribute('x')) + Number(socket.getAttribute('width')) / 2,
        Number(socket.getAttribute('y')) + Number(socket.getAttribute('height')) / 2
      );

      const irisPosition = new Point(
        Number(this.iris.getAttribute('cx')),
        Number(this.iris.getAttribute('cy'))
      );
      console.log(irisPosition);

      this.radius = this.center.distanceTo(irisPosition);
      console.log('radius', this.radius);

      // this.#set(this.center);
      this.target(new Point(100, 100));
    }

    target(point: Point) {
      const clientPosition = this.socket.getBoundingClientRect();
      const clientCenter = new Point(
        clientPosition.x + this.center.x,
        clientPosition.y + this.center.y
      );

      const vectorToTarget = new Vector(point.x - clientCenter.x, point.y - clientCenter.y);
      console.log('vectorToTarget', vectorToTarget);

      const normalizedVectorTowardsTarget = vectorToTarget.normalized;
      console.log('normalizedVectorTowardsTarget', normalizedVectorTowardsTarget);

      const vectorFromCenter = normalizedVectorTowardsTarget.multiply(this.radius);
      console.log('vectorFromCenter', vectorFromCenter);

      const newPoint = new Point(
        this.center.x + vectorFromCenter.x,
        this.center.y + vectorFromCenter.y
      );

      this.#set(newPoint);
    }

    #set(point: Point) {
      this.iris.setAttribute('cx', point.x.toString());
      this.iris.setAttribute('cy', point.y.toString());
    }
  }

  type GetEyeResult =
    | { success: false; reason: string }
    | { success: true; eye: Eye };

  function getEye(stacky: SVGElement, side: Side): GetEyeResult {
    const eye = stacky.querySelector(`.eye.${side}`);
    if (eye == null) {
      return { success: false, reason: 'eye not found' };
    }

    const socket = eye.querySelector('.socket');
    if (!(socket instanceof SVGRectElement)) {
      return { success: false, reason: 'socket not found' };
    }

    const iris = eye.querySelector('.iris');
    if (!(iris instanceof SVGEllipseElement)) {
      return { success: false, reason: 'iris not found' };
    }

    return { success: true, eye: new Eye(side, socket, iris) };
  }

  (() => {
    const stacky = document.querySelector('.stacky');
    if (!(stacky instanceof SVGElement)) {
      console.log('stacky not found');
      return;
    }

    const leftResult = getEye(stacky, 'left');
    if (!leftResult.success) {
      console.log('failed to get left eye:', leftResult.reason);
      return;
    }

    const rightResult = getEye(stacky, 'right');
    if (!rightResult.success) {
      console.log('failed to get right eye:', rightResult.reason);
      return;
    }

    const eyes = [leftResult.eye, rightResult.eye];

    document.addEventListener('mousemove', (e) => {
      // TODO: do both eyes
      const leftEye = eyes[0];
      for (const eye of [leftEye]) {
        eye.target(new Point(e.clientX, e.clientY));
      }
    });

    console.log('done');
  })();
</script>
